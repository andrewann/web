<!doctype html>

<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Генератор случайных фонов — 30 режимов</title>
  <style>
    :root{--ui-bg:rgba(10,10,12,0.6);--accent:#ffffff}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial;background:#111;color:#fff}
    .app{height:100%;display:flex;flex-direction:column}
    header{padding:14px 18px;display:flex;gap:12px;align-items:center;backdrop-filter:blur(6px);background:linear-gradient(180deg, rgba(0,0,0,0.2), rgba(0,0,0,0.05))}
    select{padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.03);color:var(--accent);font-weight:600}
    main{flex:1;position:relative;overflow:hidden}
    canvas#preview{position:absolute;inset:0;width:100%;height:100%;display:block}/* bottom-right big button */
.controls{position:absolute;right:20px;bottom:20px;display:flex;gap:12px;align-items:center}
.btn{appearance:none;border:0;padding:14px 18px;border-radius:16px;font-weight:700;cursor:pointer;background:linear-gradient(135deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));backdrop-filter: blur(6px)}
.btn:active{transform:translateY(1px)}
.save-btn{position:absolute;left:20px;bottom:20px;padding:8px 10px;border-radius:10px;font-size:13px}

/* footer small hints */
footer{position:absolute;left:18px;top:18px;font-size:13px;opacity:0.8}

/* UI badges */
.mode-info{margin-left:8px;font-weight:600;opacity:0.9}

/* responsive */
@media (max-width:600px){.btn{padding:10px 12px;border-radius:12px}}

  </style>
</head>
<body>
  <div class="app">
    <header>
      <label for="mode">Режим:</label>
      <select id="mode" title="Выберите режим">
        <!-- 30 режимов -->
      </select>
      <div class="mode-info" id="modeName"></div>
    </header>
    <main>
      <canvas id="preview"></canvas><div class="controls">
    <button id="randomize" class="btn">Сгенерировать фон</button>
    <button id="regenerate" class="btn">Регенирать вариацию</button>
  </div>

  <button id="save" class="btn save-btn">Сохранить 4K (портрет)</button>

  <footer>Нажмите «Сгенерировать фон» или смените режим в списке. Сохранение запускает отрисовку в портретном 4K (2160×3840).</footer>
</main>

  </div>  <script>
  // --- CONFIG ---
  const MODES = [
    '1 — Линейный градиент (случайные цвета)',
    '2 — Радиальный градиент (радиусный)',
    '3 — Рандомная текстура (шум)',
    '4 — Полупрозрачные шары (bokeh)',
    '5 — Диагональные полосы',
    '6 — Вертикальные полосы',
    '7 — Клетчатый паттерн',
    '8 — Волны (синусоидальные)',
    '9 — Мармур (soft noise)',
    '10 — Акварельные пятна',
    '11 — Звёздное небо',
    '12 — Металлический блеск',
    '13 — Деревянная текстура (зерно)',
    '14 — Бумажная текстура (шум + зерно)',
    '15 — Полосы-зубцы (halftone-ish)',
    '16 — Конфетти',
    '17 — Стеклянный (frosted glass)',
    '18 — Радужный градиент',
    '19 — Радиальные кольца',
    '20 — Небула (космическая текстура)',
    '21 — Шероховатый металл',
    '22 — Псевдо low-poly (triangles)',
    '23 — Брызги краски',
    '24 — Сетка + световые пересечения',
    '25 — Ретро-сетка (grid glow)',
    '26 — Матрица (rain)',
    '27 — Целлюлярный автомат (simple)',
    '28 — Полосы с градиентной заливкой',
    '29 — Боке (много слоёв)',
    '30 — Абстрактные фигуры (случайные фигуры)'
  ];

  // fill select
  const select = document.getElementById('mode');
  MODES.forEach((m,i)=>{
    const opt = document.createElement('option');opt.value = i;opt.textContent = m;select.appendChild(opt);
  });
  const modeName = document.getElementById('modeName');
  modeName.textContent = MODES[0];

  // canvas setup
  const preview = document.getElementById('preview');
  const ctx = preview.getContext('2d');

  function resizeCanvas(){
    preview.width = Math.max(800, Math.floor(window.innerWidth * window.devicePixelRatio));
    preview.height = Math.max(600, Math.floor(window.innerHeight * window.devicePixelRatio)) ;
    preview.style.width = '100%'; preview.style.height = '100%';
  }
  window.addEventListener('resize', ()=>{resizeCanvas(); renderPreview(currentMode)});
  resizeCanvas();

  // helper utils
  function rand(min=0,max=1){return Math.random()*(max-min)+min}
  function pick(arr){return arr[Math.floor(Math.random()*arr.length)]}
  function lerp(a,b,t){return a+(b-a)*t}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}

  function hexToRgb(h){
    if(!h) return [255,255,255];
    if(h[0]==='#') h=h.slice(1);
    if(h.length===3) h = h.split('').map(c=>c+c).join('');
    const n = parseInt(h,16); return [(n>>16)&255,(n>>8)&255,n&255];
  }

  // noise generator (simple value noise)
  function createNoise(width,height){
    const data = new Float32Array(width*height);
    for(let y=0;y<height;y++) for(let x=0;x<width;x++) data[y*width+x] = Math.random();
    return {width,height,data};
  }

  function drawNoiseTo(ctx,w,h,scale=1,intensity=1){
    const img = ctx.createImageData(w,h);
    for(let i=0;i<w*h;i++){
      const v = Math.floor(Math.random()*255*intensity);
      img.data[i*4+0]=v;img.data[i*4+1]=v;img.data[i*4+2]=v;img.data[i*4+3]=255;
    }
    ctx.putImageData(img,0,0);
  }

  // small utilities to create offscreen canvases
  function makeCanvas(w,h){const c=document.createElement('canvas');c.width=w;c.height=h;return c}

  // draw functions for modes
  function drawLinearGradient(cctx,w,h){
    const g = cctx.createLinearGradient(0,0,w,rand(0,h));
    const c1 = `hsl(${Math.floor(rand(0,360))} ${Math.floor(rand(60,95))}% ${Math.floor(rand(30,70))}%)`;
    const c2 = `hsl(${Math.floor(rand(0,360))} ${Math.floor(rand(60,95))}% ${Math.floor(rand(30,70))}%)`;
    g.addColorStop(0,c1); g.addColorStop(1,c2);
    cctx.fillStyle = g; cctx.fillRect(0,0,w,h);
  }

  function drawRadialGradient(cctx,w,h){
    const cx = rand(0,w); const cy = rand(0,h); const r = Math.max(w,h)*rand(0.5,1.5);
    const g = cctx.createRadialGradient(cx,cy,10,cx,cy,r);
    g.addColorStop(0,`hsl(${Math.floor(rand(0,360))} ${Math.floor(rand(50,95))}% ${Math.floor(rand(30,70))}%)`);
    g.addColorStop(1,`hsl(${Math.floor(rand(0,360))} ${Math.floor(rand(30,80))}% ${Math.floor(rand(10,50))}%)`);
    cctx.fillStyle = g; cctx.fillRect(0,0,w,h);
  }

  function drawRandomTexture(cctx,w,h){
    drawNoiseTo(cctx,w,h,1,0.4);
    cctx.globalCompositeOperation='overlay';
    drawLinearGradient(cctx,w,h);
    cctx.globalCompositeOperation='source-over';
  }

  function drawBokeh(cctx,w,h){
    cctx.fillStyle='black';cctx.fillRect(0,0,w,h);
    const n = Math.floor(40* (w/1200));
    for(let i=0;i<n;i++){
      const r = rand(40,200)*(w/1200);
      cctx.beginPath(); cctx.arc(rand(0,w),rand(0,h),r,0,Math.PI*2);
      cctx.fillStyle = `rgba(${Math.floor(rand(0,255))},${Math.floor(rand(0,255))},${Math.floor(rand(0,255))},${rand(0.08,0.28)})`;
      cctx.fill();
    }
  }

  function drawStripes(cctx,w,h,dir='diag'){
    const step = Math.floor(rand(30,160));
    cctx.fillStyle='white';cctx.fillRect(0,0,w,h);
    cctx.globalCompositeOperation='multiply';
    for(let x=-w;x<w*2;x+=step){
      cctx.beginPath();
      if(dir==='diag') cctx.rect(x,x*0.6,w*0.2,h);
      else if(dir==='vert') cctx.rect(x,0,step/3,h);
      else cctx.rect(0,x,w,step/3);
      cctx.fillStyle = `rgba(${Math.floor(rand(0,255))},${Math.floor(rand(0,255))},${Math.floor(rand(0,255))},${rand(0.06,0.22)})`;
      cctx.fill();
    }
    cctx.globalCompositeOperation='source-over';
  }

  function drawChecker(cctx,w,h){
    const cols = Math.floor(rand(4,12)); const rows = Math.floor(cols*(h/w));
    const cw = Math.ceil(w/cols); const ch=Math.ceil(h/rows);
    for(let y=0;y<rows;y++) for(let x=0;x<cols;x++){
      cctx.fillStyle = ((x+y)%2===0)? `hsl(${Math.floor(rand(0,360))} 60% ${Math.floor(rand(30,70))}%)` : `hsl(${Math.floor(rand(0,360))} 50% ${Math.floor(rand(10,40))}%)`;
      cctx.fillRect(x*cw,y*ch,cw,ch);
    }
  }

  function drawWaves(cctx,w,h){
    drawLinearGradient(cctx,w,h);
    cctx.globalCompositeOperation='soft-light';
    cctx.strokeStyle='rgba(255,255,255,0.03)'; cctx.lineWidth=2;
    const amp = rand(10,80); const freq = rand(0.005,0.03);
    for(let y=0;y<h;y+=Math.max(8, h/60)){
      cctx.beginPath();
      for(let x=0;x<w;x+=10){
        cctx.lineTo(x, y + Math.sin(x*freq + y*0.01)*amp);
      }
      cctx.stroke();
    }
    cctx.globalCompositeOperation='source-over';
  }

  function drawMarble(cctx,w,h){
    const off = makeCanvas(w,h); const oc = off.getContext('2d');
    drawRandomTexture(oc,w,h);
    // blur a little
    for(let i=0;i<3;i++){oc.globalAlpha=0.6;oc.drawImage(off,2,0,w,h);}
    cctx.drawImage(off,0,0);
  }

  function drawInkSpatter(cctx,w,h){
    cctx.fillStyle='black'; cctx.fillRect(0,0,w,h);
    for(let i=0;i<80;i++){
      cctx.beginPath();const x=rand(0,w),y=rand(0,h),r=rand(4,120);cctx.arc(x,y,r,0,Math.PI*2);
      cctx.fillStyle=`rgba(${Math.floor(rand(0,255))},${Math.floor(rand(0,255))},${Math.floor(rand(0,255))},${rand(0.12,0.9)})`;
      cctx.fill();
    }
  }

  function drawStars(cctx,w,h){
    drawRadialGradient(cctx,w,h);
    const n = Math.floor(200*(w/1200));
    for(let i=0;i<n;i++){cctx.fillStyle='white';cctx.fillRect(rand(0,w),rand(0,h),Math.random()*2,Math.random()*2)}
  }

  function drawLowPoly(cctx,w,h){
    const tris = Math.floor(rand(40,200));
    for(let t=0;t<tris;t++){
      cctx.beginPath();
      const x1=rand(0,w),y1=rand(0,h); const x2=rand(0,w),y2=rand(0,h); const x3=rand(0,w),y3=rand(0,h);
      cctx.moveTo(x1,y1);cctx.lineTo(x2,y2);cctx.lineTo(x3,y3);
      cctx.closePath();
      cctx.fillStyle = `hsl(${Math.floor(rand(0,360))} ${Math.floor(rand(30,80))}% ${Math.floor(rand(20,60))}%)`;
      cctx.fill();
    }
  }

  function drawConfetti(cctx,w,h){
    cctx.fillStyle='black';cctx.fillRect(0,0,w,h);
    for(let i=0;i<500;i++){
      cctx.fillStyle = `hsla(${Math.floor(rand(0,360))},70%,60%,${rand(0.5,1)})`;
      const x=rand(0,w),y=rand(0,h),s=rand(4,24);
      cctx.fillRect(x,y,s,Math.max(2,s*0.4));
    }
  }

  function drawGlass(cctx,w,h){
    drawLinearGradient(cctx,w,h);
    cctx.fillStyle='rgba(255,255,255,0.06)';
    for(let i=0;i<150;i++){cctx.beginPath();cctx.arc(rand(0,w),rand(0,h),rand(20,120),0,Math.PI*2);cctx.fill();}
  }

  function drawRadialRings(cctx,w,h){
    const cx=w/2,cy=h/2;const rings= Math.floor(rand(6,40));
    for(let i=rings;i>0;i--){
      cctx.beginPath(); cctx.arc(cx,cy,(i/rings)*Math.max(w,h),0,Math.PI*2);
      cctx.fillStyle = `rgba(${Math.floor(rand(0,255))},${Math.floor(rand(0,255))},${Math.floor(rand(0,255))},${rand(0.02,0.12)})`;
      cctx.fill();
    }
  }

  function drawNebula(cctx,w,h){
    drawRadialGradient(cctx,w,h);
    cctx.globalCompositeOperation='lighter';
    for(let i=0;i<6;i++){
      const cx=rand(0,w),cy=rand(0,h),r=rand(200,1000);
      const g=cctx.createRadialGradient(cx,cy,10,cx,cy,r);
      g.addColorStop(0,`hsla(${Math.floor(rand(200,360))},80%,50%,0.08)`);
      g.addColorStop(1,'rgba(0,0,0,0)');
      cctx.fillStyle=g; cctx.fillRect(0,0,w,h);
    }
    cctx.globalCompositeOperation='source-over';
  }

  function drawGrid(cctx,w,h){
    drawLinearGradient(cctx,w,h);
    cctx.strokeStyle='rgba(255,255,255,0.04)'; cctx.lineWidth=1;
    const step = Math.floor(rand(30,120));
    for(let x=0;x<w;x+=step){cctx.beginPath();cctx.moveTo(x,0);cctx.lineTo(x,h);cctx.stroke();}
    for(let y=0;y<h;y+=step){cctx.beginPath();cctx.moveTo(0,y);cctx.lineTo(w,y);cctx.stroke();}
  }

  function drawMatrix(cctx,w,h){
    cctx.fillStyle='black'; cctx.fillRect(0,0,w,h);
    cctx.font = `${Math.floor(w/50)}px monospace`;
    cctx.globalAlpha = 0.15;
    for(let i=0;i<200;i++){
      const x = rand(0,w); const y = rand(0,h);
      cctx.fillStyle = `hsl(${Math.floor(rand(120,140))} 80% ${Math.floor(rand(20,70))}%)`;
      cctx.fillText(String.fromCharCode(0x30A0 + Math.floor(rand(0,96))), x, y);
    }
    cctx.globalAlpha=1;
  }

  function drawHalftone(cctx,w,h){
    drawLinearGradient(cctx,w,h);
    const step = Math.max(6, Math.floor(w/200));
    for(let y=0;y<h;y+=step){ for(let x=0;x<w;x+=step){
      const r = Math.abs(Math.sin((x+y)/40))*step;
      cctx.fillStyle = `rgba(0,0,0,0.06)`; cctx.beginPath(); cctx.arc(x,y,r,0,Math.PI*2); cctx.fill();
    }}
  }

  function drawRandomShapes(cctx,w,h){
    drawLinearGradient(cctx,w,h);
    for(let i=0;i<40;i++){
      cctx.beginPath();const s=rand(20,400);
      cctx.moveTo(rand(0,w),rand(0,h)); for(let k=0;k<rand(3,8);k++) cctx.lineTo(rand(0,w),rand(0,h));
      cctx.closePath(); cctx.fillStyle=`hsla(${Math.floor(rand(0,360))},70%,50%,${rand(0.2,0.85)})`; cctx.fill();
    }
  }

  // main dispatcher
  function renderMode(ctx,w,h,modeIndex){
    ctx.clearRect(0,0,w,h);
    switch(modeIndex){
      case 0: drawLinearGradient(ctx,w,h); break;
      case 1: drawRadialGradient(ctx,w,h); break;
      case 2: drawRandomTexture(ctx,w,h); break;
      case 3: drawBokeh(ctx,w,h); break;
      case 4: drawStripes(ctx,w,h,'diag'); break;
      case 5: drawStripes(ctx,w,h,'vert'); break;
      case 6: drawChecker(ctx,w,h); break;
      case 7: drawWaves(ctx,w,h); break;
      case 8: drawMarble(ctx,w,h); break;
      case 9: drawInkSpatter(ctx,w,h); break;
      case 10: drawStars(ctx,w,h); break;
      case 11: drawMetallic(ctx,w,h); break;
      case 12: drawWood(ctx,w,h); break;
      case 13: drawPaper(ctx,w,h); break;
      case 14: drawHalftone(ctx,w,h); break;
      case 15: drawConfetti(ctx,w,h); break;
      case 16: drawGlass(ctx,w,h); break;
      case 17: drawRadialGradient(ctx,w,h); break;
      case 18: drawRadialRings(ctx,w,h); break;
      case 19: drawNebula(ctx,w,h); break;
      case 20: drawRoughMetal(ctx,w,h); break;
      case 21: drawLowPoly(ctx,w,h); break;
      case 22: drawInkSpatter(ctx,w,h); break;
      case 23: drawGrid(ctx,w,h); break;
      case 24: drawGridGlow(ctx,w,h); break;
      case 25: drawMatrix(ctx,w,h); break;
      case 26: drawCellular(ctx,w,h); break;
      case 27: drawStripes(ctx,w,h,'diag'); break;
      case 28: drawBokeh(ctx,w,h); break;
      case 29: drawRandomShapes(ctx,w,h); break;
      default: drawLinearGradient(ctx,w,h);
    }
  }

  // fallback/minor implementations for modes referenced above
  function drawMetallic(cctx,w,h){ drawLinearGradient(cctx,w,h); cctx.globalCompositeOperation='overlay'; drawStripes(cctx,w,h,'vert'); cctx.globalCompositeOperation='source-over'; }
  function drawWood(cctx,w,h){ drawLinearGradient(cctx,w,h); const lines=200; cctx.globalAlpha=0.06; for(let i=0;i<lines;i++){cctx.beginPath();cctx.moveTo(0,i*(h/lines));cctx.bezierCurveTo(w*0.2,i*(h/lines)+rand(-20,20),w*0.8,i*(h/lines)+rand(-20,20),w,i*(h/lines)); cctx.strokeStyle='rgba(0,0,0,0.06)'; cctx.stroke();} cctx.globalAlpha=1; }
  function drawPaper(cctx,w,h){ drawRandomTexture(cctx,w,h); cctx.globalCompositeOperation='multiply'; cctx.fillStyle='rgba(255,255,255,0.04)'; cctx.fillRect(0,0,w,h); cctx.globalCompositeOperation='source-over'; }
  function drawRoughMetal(cctx,w,h){ drawLinearGradient(cctx,w,h); drawNoiseTo(cctx,Math.floor(w/2),Math.floor(h/2)); }
  function drawGridGlow(cctx,w,h){ drawGrid(cctx,w,h); cctx.globalCompositeOperation='lighter'; cctx.fillStyle='rgba(255,255,255,0.02)'; cctx.fillRect(0,0,w,h); cctx.globalCompositeOperation='source-over'; }
  function drawCellular(cctx,w,h){ // very simple cellular-like dots
    drawLinearGradient(cctx,w,h);
    for(let i=0;i<120;i++){cctx.beginPath();cctx.arc(rand(0,w),rand(0,h),rand(4,40),0,Math.PI*2);cctx.fillStyle=`rgba(${Math.floor(rand(0,255))},${Math.floor(rand(0,255))},${Math.floor(rand(0,255))},${rand(0.06,0.4)})`;cctx.fill();}
  }

  // render preview (scaled)
  let currentMode = 0;
  function renderPreview(modeIndex){
    currentMode = typeof modeIndex === 'number' ? modeIndex : currentMode;
    const w = preview.width; const h = preview.height;
    renderOffscreenTo(ctx,w,h,currentMode);
    modeName.textContent = MODES[currentMode];
  }

  function renderOffscreenTo(targetCtx,w,h,modeIndex){
    const off = makeCanvas(w,h); const oc = off.getContext('2d');
    renderMode(oc,w,h,modeIndex);
    targetCtx.clearRect(0,0,w,h);
    targetCtx.drawImage(off,0,0);
  }

  // initial render
  renderPreview(0);

  // UI events
  document.getElementById('randomize').addEventListener('click', ()=>{ renderPreview(Math.floor(rand(0,MODES.length))); });
  document.getElementById('regenerate').addEventListener('click', ()=>{ renderPreview(currentMode); });
  select.addEventListener('change',(e)=>{ renderPreview(parseInt(e.target.value)); });

  // save 4k portrait
  document.getElementById('save').addEventListener('click', async ()=>{
    const tw = 2160; const th = 3840; // portrait 4K: width x height
    const off = makeCanvas(tw,th); const oc = off.getContext('2d');
    // render high-res
    renderMode(oc,tw,th,currentMode);
    // create blob and download
    off.toBlob(function(blob){
      const a = document.createElement('a'); a.download = `bg_mode${currentMode+1}_${Date.now()}.png`; a.href = URL.createObjectURL(blob);
      document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); },2000);
    }, 'image/png');
  });

  // allow keyboard: space = random
  window.addEventListener('keydown',(e)=>{ if(e.code==='Space'){ e.preventDefault(); renderPreview(Math.floor(rand(0,MODES.length))); } });

  // quick touch: tap preview to randomize
  preview.addEventListener('click', ()=>{ renderPreview(Math.floor(rand(0,MODES.length))); });
  </script></body>
</html>