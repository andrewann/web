<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор случайных фонов</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }
        #modes {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 10;
            padding: 5px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
        }
        #generate {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
        }
        #save {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
        }
        button:hover {
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <canvas id="bg"></canvas>
    <select id="modes">
        <option value="1">1. Линейный градиент</option>
        <option value="2">2. Радиальный градиент</option>
        <option value="3">3. Рандомная текстура (шум)</option>
        <option value="4">4. Полупрозрачные шары</option>
        <option value="5">5. Волнистые линии</option>
        <option value="6">6. Клетчатый узор</option>
        <option value="7">7. Полосы</option>
        <option value="8">8. Точки</option>
        <option value="9">9. Шестиугольники</option>
        <option value="10">10. Перлин-шум</option>
        <option value="11">11. Фрактальный узор</option>
        <option value="12">12. Мозаика</option>
        <option value="13">13. Абстрактные формы</option>
        <option value="14">14. Геометрические фигуры</option>
        <option value="15">15. Радужный градиент</option>
        <option value="16">16. Звёздное небо</option>
        <option value="17">17. Водные блики</option>
        <option value="18">18. Лесной камуфляж</option>
        <option value="19">19. Металлический блеск</option>
        <option value="20">20. Огненный эффект</option>
        <option value="21">21. Ледяные кристаллы</option>
        <option value="22">22. Песчаные дюны</option>
        <option value="23">23. Космический вихрь</option>
        <option value="24">24. Органические формы</option>
        <option value="25">25. Пиксель-арт</option>
        <option value="26">26. Вихревой градиент</option>
        <option value="27">27. Теневые слои</option>
        <option value="28">28. Цветочные узоры</option>
        <option value="29">29. Голографический эффект</option>
        <option value="30">30. Абстрактный экспрессионизм</option>
    </select>
    <button id="generate">Генерировать</button>
    <button id="save">Сохранить 4K</button>

    <script>
        const canvas = document.getElementById('bg');
        const ctx = canvas.getContext('2d');
        const modes = document.getElementById('modes');
        const generateBtn = document.getElementById('generate');
        const saveBtn = document.getElementById('save');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Функция для случайных цветов
        function randomColor() {
            return `hsl(${Math.random() * 360}, ${50 + Math.random() * 50}%, ${40 + Math.random() * 40}%)`;
        }

        // Функция для генерации шума (простой)
        function generateNoise(width, height, opacity = 0.1) {
            const imageData = ctx.createImageData(width, height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const noise = Math.random() * 255;
                imageData.data[i] = noise; // R
                imageData.data[i + 1] = noise; // G
                imageData.data[i + 2] = noise; // B
                imageData.data[i + 3] = opacity * 255; // A
            }
            return imageData;
        }

        // Генерация фонов по режимам (упрощённые реализации)
        function generateBackground(mode) {
            const w = canvas.width;
            const h = canvas.height;
            ctx.clearRect(0, 0, w, h);

            switch (parseInt(mode)) {
                case 1: // Линейный градиент
                    const grad1 = ctx.createLinearGradient(0, 0, w, h);
                    grad1.addColorStop(0, randomColor());
                    grad1.addColorStop(1, randomColor());
                    ctx.fillStyle = grad1;
                    ctx.fillRect(0, 0, w, h);
                    break;
                case 2: // Радиальный градиент
                    const grad2 = ctx.createRadialGradient(w/2 + (Math.random()-0.5)*w, h/2 + (Math.random()-0.5)*h, 0, w/2, h/2, Math.max(w, h));
                    grad2.addColorStop(0, randomColor());
                    grad2.addColorStop(1, randomColor());
                    ctx.fillStyle = grad2;
                    ctx.fillRect(0, 0, w, h);
                    break;
                case 3: // Рандомная текстура (шум)
                    ctx.putImageData(generateNoise(w, h), 0, 0);
                    break;
                case 4: // Полупрозрачные шары
                    for (let i = 0; i < 50; i++) {
                        ctx.beginPath();
                        ctx.arc(Math.random() * w, Math.random() * h, 20 + Math.random() * 80, 0, Math.PI * 2);
                        ctx.fillStyle = randomColor() + '80'; // Полупрозрачный
                        ctx.fill();
                    }
                    break;
                case 5: // Волнистые линии
                    ctx.strokeStyle = randomColor();
                    ctx.lineWidth = 2;
                    for (let x = 0; x < w; x += 20) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        for (let y = 0; y < h; y += 10) {
                            ctx.lineTo(x + Math.sin(y / 50) * 20, y);
                        }
                        ctx.stroke();
                    }
                    break;
                case 6: // Клетчатый узор
                    const size = 50 + Math.random() * 50;
                    for (let x = 0; x < w; x += size) {
                        for (let y = 0; y < h; y += size) {
                            ctx.fillStyle = Math.random() > 0.5 ? randomColor() : 'transparent';
                            ctx.fillRect(x, y, size, size);
                        }
                    }
                    break;
                case 7: // Полосы
                    const stripeWidth = 30 + Math.random() * 50;
                    for (let y = 0; y < h; y += stripeWidth) {
                        ctx.fillStyle = randomColor();
                        ctx.fillRect(0, y, w, stripeWidth);
                    }
                    break;
                case 8: // Точки
                    for (let i = 0; i < 1000; i++) {
                        ctx.beginPath();
                        ctx.arc(Math.random() * w, Math.random() * h, Math.random() * 5, 0, Math.PI * 2);
                        ctx.fillStyle = randomColor();
                        ctx.fill();
                    }
                    break;
                case 9: // Шестиугольники (упрощённо)
                    const hexSize = 30;
                    for (let x = 0; x < w; x += hexSize * 1.732) {
                        for (let y = 0; y < h; y += hexSize * 1.5) {
                            ctx.beginPath();
                            for (let i = 0; i < 6; i++) {
                                const angle = (Math.PI / 3) * i;
                                const px = x + hexSize * Math.cos(angle);
                                const py = y + hexSize * Math.sin(angle);
                                if (i === 0) ctx.moveTo(px, py);
                                else ctx.lineTo(px, py);
                            }
                            ctx.closePath();
                            ctx.fillStyle = randomColor() + 'CC';
                            ctx.fill();
                        }
                    }
                    break;
                case 10: // Перлин-шум (упрощённый с Math.random)
                    const noiseData = generateNoise(w, h, 0.05);
                    ctx.putImageData(noiseData, 0, 0);
                    // Добавим градиент для цвета
                    const grad10 = ctx.createLinearGradient(0, 0, w, h);
                    grad10.addColorStop(0, '#000');
                    grad10.addColorStop(1, '#fff');
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.fillStyle = grad10;
                    ctx.fillRect(0, 0, w, h);
                    ctx.globalCompositeOperation = 'source-over';
                    break;
                case 11: // Фрактальный узор (рекурсивные треугольники)
                    function drawFractal(x, y, size, depth) {
                        if (depth === 0) return;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + size, y);
                        ctx.lineTo(x + size / 2, y - size * 0.866);
                        ctx.closePath();
                        ctx.fillStyle = randomColor() + Math.floor(depth * 30).toString(16).padStart(2, '0');
                        ctx.fill();
                        const s = size / 2;
                        drawFractal(x, y, s, depth - 1);
                        drawFractal(x + s, y, s, depth - 1);
                        drawFractal(x + s / 2, y - s * 0.866, s, depth - 1);
                    }
                    drawFractal(w/2, h, 200, 5);
                    break;
                case 12: // Мозаика
                    const mosaicSize = 40;
                    for (let x = 0; x < w; x += mosaicSize) {
                        for (let y = 0; y < h; y += mosaicSize) {
                            ctx.beginPath();
                            ctx.rect(x, y, mosaicSize, mosaicSize);
                            ctx.fillStyle = randomColor();
                            ctx.fill();
                            // Добавим случайные линии
                            if (Math.random() > 0.5) {
                                ctx.strokeStyle = randomColor();
                                ctx.lineTo(x + mosaicSize, y + Math.random() * mosaicSize);
                                ctx.stroke();
                            }
                        }
                    }
                    break;
                case 13: // Абстрактные формы
                    for (let i = 0; i < 20; i++) {
                        ctx.beginPath();
                        ctx.ellipse(Math.random() * w, Math.random() * h, 50 + Math.random() * 100, 30 + Math.random() * 50, Math.random() * Math.PI, 0, Math.PI * 2);
                        ctx.fillStyle = randomColor() + '80';
                        ctx.fill();
                    }
                    break;
                case 14: // Геометрические фигуры
                    const shapes = ['rect', 'circle', 'triangle'];
                    for (let i = 0; i < 50; i++) {
                        const shape = shapes[Math.floor(Math.random() * shapes.length)];
                        ctx.fillStyle = randomColor();
                        if (shape === 'rect') {
                            ctx.fillRect(Math.random() * w, Math.random() * h, 50, 30);
                        } else if (shape === 'circle') {
                            ctx.beginPath();
                            ctx.arc(Math.random() * w, Math.random() * h, 25, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            // Triangle
                            ctx.beginPath();
                            ctx.moveTo(Math.random() * w, Math.random() * h);
                            ctx.lineTo(Math.random() * w, Math.random() * h);
                            ctx.lineTo(Math.random() * w, Math.random() * h);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                    break;
                case 15: // Радужный градиент
                    const grad15 = ctx.createLinearGradient(0, 0, w, 0);
                    const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];
                    for (let i = 0; i <= 1; i += 1/6) {
                        grad15.addColorStop(i, colors[Math.floor(i * 6)]);
                    }
                    ctx.fillStyle = grad15;
                    ctx.fillRect(0, 0, w, h);
                    break;
                case 16: // Звёздное небо
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, w, h);
                    for (let i = 0; i < 500; i++) {
                        const x = Math.random() * w;
                        const y = Math.random() * h;
                        const size = Math.random() * 2;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fillStyle = 'white';
                        ctx.fill();
                    }
                    break;
                case 17: // Водные блики
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(0, 0, w, h);
                    for (let i = 0; i < 100; i++) {
                        ctx.beginPath();
                        ctx.arc(Math.random() * w, Math.random() * h, 10 + Math.random() * 30, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.fill();
                    }
                    break;
                case 18: // Лесной камуфляж
                    for (let i = 0; i < 200; i++) {
                        ctx.fillStyle = ['#228B22', '#556B2F', '#8FBC8F'][Math.floor(Math.random() * 3)];
                        ctx.fillRect(Math.random() * w, Math.random() * h, 20 + Math.random() * 40, 10 + Math.random() * 20);
                    }
                    break;
                case 19: // Металлический блеск
                    const grad19 = ctx.createLinearGradient(0, 0, w, h);
                    grad19.addColorStop(0, '#C0C0C0');
                    grad19.addColorStop(0.5, '#A9A9A9');
                    grad19.addColorStop(1, '#808080');
                    ctx.fillStyle = grad19;
                    ctx.fillRect(0, 0, w, h);
                    // Добавим блики
                    for (let i = 0; i < 10; i++) {
                        ctx.beginPath();
                        ctx.arc(Math.random() * w, Math.random() * h, 50, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.fill();
                    }
                    break;
                case 20: // Огненный эффект
                    for (let y = h; y > 0; y -= 20) {
                        ctx.fillStyle = ['#FF4500', '#FFD700', '#FFA500'][Math.floor(Math.random() * 3)];
                        ctx.fillRect(0, y, w, 20);
                    }
                    break;
                case 21: // Ледяные кристаллы
                    ctx.fillStyle = '#ADD8E6';
                    ctx.fillRect(0, 0, w, h);
                    for (let i = 0; i < 30; i++) {
                        const x = Math.random() * w;
                        const y = Math.random() * h;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        for (let j = 0; j < 6; j++) {
                            const angle = (Math.PI / 3) * j;
                            ctx.lineTo(x + Math.cos(angle) * 30, y + Math.sin(angle) * 30);
                        }
                        ctx.closePath();
                        ctx.strokeStyle = '#4682B4';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    break;
                case 22: // Песчаные дюны
                    ctx.fillStyle = '#F4A460';
                    ctx.fillRect(0, 0, w, h);
                    ctx.strokeStyle = '#DAA520';
                    ctx.lineWidth = 1;
                    for (let x = 0; x < w; x += 50) {
                        ctx.beginPath();
                        ctx.moveTo(x, h);
                        for (let y = h; y > 0; y -= 10) {
                            ctx.lineTo(x + Math.sin(y / 100) * 50, y);
                        }
                        ctx.stroke();
                    }
                    break;
                case 23: // Космический вихрь
                    const grad23 = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w, h));
                    grad23.addColorStop(0, '#000');
                    grad23.addColorStop(0.5, '#4B0082');
                    grad23.addColorStop(1, '#000080');
                    ctx.fillStyle = grad23;
                    ctx.fillRect(0, 0, w, h);
                    // Вихрь линии
                    ctx.strokeStyle = 'white';
                    for (let i = 0; i < 10; i++) {
                        ctx.beginPath();
                        ctx.arc(w/2, h/2, 50 + i * 50, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    break;
                case 24: // Органические формы
                    for (let i = 0; i < 15; i++) {
                        ctx.beginPath();
                        const x = Math.random() * w;
                        const y = Math.random() * h;
                        ctx.ellipse(x, y, 40 + Math.random() * 60, 20 + Math.random() * 40, Math.random() * Math.PI, 0, Math.PI * 2);
                        ctx.fillStyle = randomColor() + '60';
                        ctx.fill();
                    }
                    break;
                case 25: // Пиксель-арт
                    const pixelSize = 10;
                    for (let x = 0; x < w; x += pixelSize) {
                        for (let y = 0; y < h; y += pixelSize) {
                            if (Math.random() > 0.3) {
                                ctx.fillStyle = randomColor();
                                ctx.fillRect(x, y, pixelSize, pixelSize);
                            }
                        }
                    }
                    break;
                case 26: // Вихревой градиент
                    const grad26 = ctx.createConicGradient(w/2, h/2);
                    for (let i = 0; i < 6; i++) {
                        grad26.addColorStop(i / 6, randomColor());
                    }
                    ctx.fillStyle = grad26;
                    ctx.fillRect(0, 0, w, h);
                    break;
                case 27: // Теневые слои
                    for (let i = 0; i < 5; i++) {
                        ctx.fillStyle = `rgba(0, 0, 0, ${0.1 * i})`;
                        ctx.fillRect(0, 0, w, h);
                    }
                    // Добавим светлые пятна
                    for (let j = 0; j < 20; j++) {
                        ctx.beginPath();
                        ctx.arc(Math.random() * w, Math.random() * h, 30, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, 0.2)`;
                        ctx.fill();
                    }
                    break;
                case 28: // Цветочные узоры
                    function drawFlower(x, y, size) {
                        ctx.save();
                        ctx.translate(x, y);
                        for (let i = 0; i < 8; i++) {
                            ctx.rotate(Math.PI / 4);
                            ctx.beginPath();
                            ctx.ellipse(0, 0, size, size / 2, 0, 0, Math.PI * 2);
                            ctx.fillStyle = randomColor();
                            ctx.fill();
                        }
                        ctx.restore();
                    }
                    for (let i = 0; i < 20; i++) {
                        drawFlower(Math.random() * w, Math.random() * h, 10 + Math.random() * 20);
                    }
                    break;
                case 29: // Голографический эффект
                    const grad29 = ctx.createLinearGradient(0, 0, w, h);
                    grad29.addColorStop(0, '#00FFFF');
                    grad29.addColorStop(0.5, '#FF00FF');
                    grad29.addColorStop(1, '#00FF00');
                    ctx.fillStyle = grad29;
                    ctx.fillRect(0, 0, w, h);
                    // Добавим сетку
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    for (let x = 0; x < w; x += 50) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, h);
                        ctx.stroke();
                    }
                    for (let y = 0; y < h; y += 50) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(w, y);
                        ctx.stroke();
                    }
                    break;
                case 30: // Абстрактный экспрессионизм
                    ctx.lineWidth = 5 + Math.random() * 10;
                    ctx.strokeStyle = randomColor();
                    for (let i = 0; i < 100; i++) {
                        ctx.beginPath();
                        ctx.moveTo(Math.random() * w, Math.random() * h);
                        ctx.lineTo(Math.random() * w, Math.random() * h);
                        ctx.stroke();
                    }
                    break;
                default:
                    // Fallback
                    ctx.fillStyle = randomColor();
                    ctx.fillRect(0, 0, w, h);
            }
        }

        // Сохранение в 4K портрет (2160x3840)
        function saveBackground() {
            const saveCanvas = document.createElement('canvas');
            saveCanvas.width = 2160;
            saveCanvas.height = 3840;
            const saveCtx = saveCanvas.getContext('2d');

            // Масштабируем текущий фон
            saveCtx.drawImage(canvas, 0, 0, 2160, 3840);

            const link = document.createElement('a');
            link.download = 'background_4k_portrait.png';
            link.href = saveCanvas.toDataURL('image/png');
            link.click();
        }

        // События
        modes.addEventListener('change', () => generateBackground(modes.value));
        generateBtn.addEventListener('click', () => generateBackground(modes.value));
        saveBtn.addEventListener('click', saveBackground);

        // Инициализация
        generateBackground('1');
    </script>
</body>
</html>